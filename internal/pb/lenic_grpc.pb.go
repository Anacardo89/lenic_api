// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.30.0--dev
// source: lenic.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CreateUserService_CreateUser_FullMethodName = "/lenic.CreateUserService/CreateUser"
)

// CreateUserServiceClient is the client API for CreateUserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CreateUserServiceClient interface {
	CreateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*CreateUserResponse, error)
}

type createUserServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCreateUserServiceClient(cc grpc.ClientConnInterface) CreateUserServiceClient {
	return &createUserServiceClient{cc}
}

func (c *createUserServiceClient) CreateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*CreateUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateUserResponse)
	err := c.cc.Invoke(ctx, CreateUserService_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CreateUserServiceServer is the server API for CreateUserService service.
// All implementations must embed UnimplementedCreateUserServiceServer
// for forward compatibility.
type CreateUserServiceServer interface {
	CreateUser(context.Context, *User) (*CreateUserResponse, error)
	mustEmbedUnimplementedCreateUserServiceServer()
}

// UnimplementedCreateUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCreateUserServiceServer struct{}

func (UnimplementedCreateUserServiceServer) CreateUser(context.Context, *User) (*CreateUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedCreateUserServiceServer) mustEmbedUnimplementedCreateUserServiceServer() {}
func (UnimplementedCreateUserServiceServer) testEmbeddedByValue()                           {}

// UnsafeCreateUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CreateUserServiceServer will
// result in compilation errors.
type UnsafeCreateUserServiceServer interface {
	mustEmbedUnimplementedCreateUserServiceServer()
}

func RegisterCreateUserServiceServer(s grpc.ServiceRegistrar, srv CreateUserServiceServer) {
	// If the following call pancis, it indicates UnimplementedCreateUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CreateUserService_ServiceDesc, srv)
}

func _CreateUserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreateUserServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreateUserService_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreateUserServiceServer).CreateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

// CreateUserService_ServiceDesc is the grpc.ServiceDesc for CreateUserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CreateUserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lenic.CreateUserService",
	HandlerType: (*CreateUserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _CreateUserService_CreateUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lenic.proto",
}

const (
	AuthService_Login_FullMethodName = "/lenic.AuthService/Login"
)

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthServiceClient interface {
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
}

type authServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, AuthService_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility.
type AuthServiceServer interface {
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthServiceServer struct{}

func (UnimplementedAuthServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {}
func (UnimplementedAuthServiceServer) testEmbeddedByValue()                     {}

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
	mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) {
	// If the following call pancis, it indicates UnimplementedAuthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuthService_ServiceDesc, srv)
}

func _AuthService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lenic.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _AuthService_Login_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lenic.proto",
}

const (
	Lenic_ActivateUser_FullMethodName         = "/lenic.Lenic/ActivateUser"
	Lenic_GetUser_FullMethodName              = "/lenic.Lenic/GetUser"
	Lenic_SearchUsers_FullMethodName          = "/lenic.Lenic/SearchUsers"
	Lenic_GetUserFollowers_FullMethodName     = "/lenic.Lenic/GetUserFollowers"
	Lenic_GetUserFollowing_FullMethodName     = "/lenic.Lenic/GetUserFollowing"
	Lenic_FollowUser_FullMethodName           = "/lenic.Lenic/FollowUser"
	Lenic_AcceptFollow_FullMethodName         = "/lenic.Lenic/AcceptFollow"
	Lenic_UnfollowUser_FullMethodName         = "/lenic.Lenic/UnfollowUser"
	Lenic_UpdateUserPass_FullMethodName       = "/lenic.Lenic/UpdateUserPass"
	Lenic_DeleteUser_FullMethodName           = "/lenic.Lenic/DeleteUser"
	Lenic_StartConversation_FullMethodName    = "/lenic.Lenic/StartConversation"
	Lenic_GetUserConversations_FullMethodName = "/lenic.Lenic/GetUserConversations"
	Lenic_ReadConversation_FullMethodName     = "/lenic.Lenic/ReadConversation"
	Lenic_SendDM_FullMethodName               = "/lenic.Lenic/SendDM"
	Lenic_GetConversationDMs_FullMethodName   = "/lenic.Lenic/GetConversationDMs"
	Lenic_CreatePost_FullMethodName           = "/lenic.Lenic/CreatePost"
	Lenic_GetPost_FullMethodName              = "/lenic.Lenic/GetPost"
	Lenic_GetUserPosts_FullMethodName         = "/lenic.Lenic/GetUserPosts"
	Lenic_GetUserPublicPosts_FullMethodName   = "/lenic.Lenic/GetUserPublicPosts"
	Lenic_GetFeed_FullMethodName              = "/lenic.Lenic/GetFeed"
	Lenic_RatePostUp_FullMethodName           = "/lenic.Lenic/RatePostUp"
	Lenic_RatePostDown_FullMethodName         = "/lenic.Lenic/RatePostDown"
	Lenic_UpdatePost_FullMethodName           = "/lenic.Lenic/UpdatePost"
	Lenic_DeletePost_FullMethodName           = "/lenic.Lenic/DeletePost"
	Lenic_CreateComment_FullMethodName        = "/lenic.Lenic/CreateComment"
	Lenic_GetComment_FullMethodName           = "/lenic.Lenic/GetComment"
	Lenic_GetCommentsFromPost_FullMethodName  = "/lenic.Lenic/GetCommentsFromPost"
	Lenic_RateCommentUp_FullMethodName        = "/lenic.Lenic/RateCommentUp"
	Lenic_RateCommentDown_FullMethodName      = "/lenic.Lenic/RateCommentDown"
	Lenic_UpdateComment_FullMethodName        = "/lenic.Lenic/UpdateComment"
	Lenic_DeleteComment_FullMethodName        = "/lenic.Lenic/DeleteComment"
)

// LenicClient is the client API for Lenic service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LenicClient interface {
	ActivateUser(ctx context.Context, in *ActivateUserRequest, opts ...grpc.CallOption) (*ActivateUserResponse, error)
	GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*User, error)
	SearchUsers(ctx context.Context, in *SearchUsersRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[User], error)
	GetUserFollowers(ctx context.Context, in *GetUserFollowersRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[User], error)
	GetUserFollowing(ctx context.Context, in *GetUserFollowingRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[User], error)
	FollowUser(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*FollowUserResponse, error)
	AcceptFollow(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*AcceptFollowResponse, error)
	UnfollowUser(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*UnfollowUserResponse, error)
	UpdateUserPass(ctx context.Context, in *User, opts ...grpc.CallOption) (*UpdateUserPassResponse, error)
	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error)
	StartConversation(ctx context.Context, in *Conversation, opts ...grpc.CallOption) (*StartConversationResponse, error)
	GetUserConversations(ctx context.Context, in *GetUserConversationsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Conversation], error)
	ReadConversation(ctx context.Context, in *ReadConversationRequest, opts ...grpc.CallOption) (*ReadConversationResponse, error)
	SendDM(ctx context.Context, in *DM, opts ...grpc.CallOption) (*SendDMResponse, error)
	GetConversationDMs(ctx context.Context, in *GetConversationDMsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DM], error)
	CreatePost(ctx context.Context, in *Post, opts ...grpc.CallOption) (*CreatePostResponse, error)
	GetPost(ctx context.Context, in *GetPostRequest, opts ...grpc.CallOption) (*Post, error)
	GetUserPosts(ctx context.Context, in *GetUserPostsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Post], error)
	GetUserPublicPosts(ctx context.Context, in *GetUserPublicPostsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Post], error)
	GetFeed(ctx context.Context, in *GetFeedRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Post], error)
	RatePostUp(ctx context.Context, in *PostRating, opts ...grpc.CallOption) (*RatePostUpResponse, error)
	RatePostDown(ctx context.Context, in *PostRating, opts ...grpc.CallOption) (*RatePostDownResponse, error)
	UpdatePost(ctx context.Context, in *Post, opts ...grpc.CallOption) (*UpdatePostResponse, error)
	DeletePost(ctx context.Context, in *DeletePostRequest, opts ...grpc.CallOption) (*DeletePostResponse, error)
	CreateComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*CreateCommentResponse, error)
	GetComment(ctx context.Context, in *GetCommentRequest, opts ...grpc.CallOption) (*Comment, error)
	GetCommentsFromPost(ctx context.Context, in *GetCommentsFromPostRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Comment], error)
	RateCommentUp(ctx context.Context, in *CommentRating, opts ...grpc.CallOption) (*RateCommentUpResponse, error)
	RateCommentDown(ctx context.Context, in *CommentRating, opts ...grpc.CallOption) (*RateCommentDownResponse, error)
	UpdateComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*UpdateCommentResponse, error)
	DeleteComment(ctx context.Context, in *DeleteCommentRequest, opts ...grpc.CallOption) (*DeleteCommentResponse, error)
}

type lenicClient struct {
	cc grpc.ClientConnInterface
}

func NewLenicClient(cc grpc.ClientConnInterface) LenicClient {
	return &lenicClient{cc}
}

func (c *lenicClient) ActivateUser(ctx context.Context, in *ActivateUserRequest, opts ...grpc.CallOption) (*ActivateUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActivateUserResponse)
	err := c.cc.Invoke(ctx, Lenic_ActivateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, Lenic_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) SearchUsers(ctx context.Context, in *SearchUsersRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[User], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lenic_ServiceDesc.Streams[0], Lenic_SearchUsers_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SearchUsersRequest, User]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_SearchUsersClient = grpc.ServerStreamingClient[User]

func (c *lenicClient) GetUserFollowers(ctx context.Context, in *GetUserFollowersRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[User], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lenic_ServiceDesc.Streams[1], Lenic_GetUserFollowers_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetUserFollowersRequest, User]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserFollowersClient = grpc.ServerStreamingClient[User]

func (c *lenicClient) GetUserFollowing(ctx context.Context, in *GetUserFollowingRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[User], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lenic_ServiceDesc.Streams[2], Lenic_GetUserFollowing_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetUserFollowingRequest, User]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserFollowingClient = grpc.ServerStreamingClient[User]

func (c *lenicClient) FollowUser(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*FollowUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FollowUserResponse)
	err := c.cc.Invoke(ctx, Lenic_FollowUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) AcceptFollow(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*AcceptFollowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AcceptFollowResponse)
	err := c.cc.Invoke(ctx, Lenic_AcceptFollow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) UnfollowUser(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*UnfollowUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnfollowUserResponse)
	err := c.cc.Invoke(ctx, Lenic_UnfollowUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) UpdateUserPass(ctx context.Context, in *User, opts ...grpc.CallOption) (*UpdateUserPassResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateUserPassResponse)
	err := c.cc.Invoke(ctx, Lenic_UpdateUserPass_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserResponse)
	err := c.cc.Invoke(ctx, Lenic_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) StartConversation(ctx context.Context, in *Conversation, opts ...grpc.CallOption) (*StartConversationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartConversationResponse)
	err := c.cc.Invoke(ctx, Lenic_StartConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) GetUserConversations(ctx context.Context, in *GetUserConversationsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Conversation], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lenic_ServiceDesc.Streams[3], Lenic_GetUserConversations_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetUserConversationsRequest, Conversation]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserConversationsClient = grpc.ServerStreamingClient[Conversation]

func (c *lenicClient) ReadConversation(ctx context.Context, in *ReadConversationRequest, opts ...grpc.CallOption) (*ReadConversationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadConversationResponse)
	err := c.cc.Invoke(ctx, Lenic_ReadConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) SendDM(ctx context.Context, in *DM, opts ...grpc.CallOption) (*SendDMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendDMResponse)
	err := c.cc.Invoke(ctx, Lenic_SendDM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) GetConversationDMs(ctx context.Context, in *GetConversationDMsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DM], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lenic_ServiceDesc.Streams[4], Lenic_GetConversationDMs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetConversationDMsRequest, DM]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetConversationDMsClient = grpc.ServerStreamingClient[DM]

func (c *lenicClient) CreatePost(ctx context.Context, in *Post, opts ...grpc.CallOption) (*CreatePostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreatePostResponse)
	err := c.cc.Invoke(ctx, Lenic_CreatePost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) GetPost(ctx context.Context, in *GetPostRequest, opts ...grpc.CallOption) (*Post, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Post)
	err := c.cc.Invoke(ctx, Lenic_GetPost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) GetUserPosts(ctx context.Context, in *GetUserPostsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Post], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lenic_ServiceDesc.Streams[5], Lenic_GetUserPosts_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetUserPostsRequest, Post]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserPostsClient = grpc.ServerStreamingClient[Post]

func (c *lenicClient) GetUserPublicPosts(ctx context.Context, in *GetUserPublicPostsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Post], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lenic_ServiceDesc.Streams[6], Lenic_GetUserPublicPosts_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetUserPublicPostsRequest, Post]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserPublicPostsClient = grpc.ServerStreamingClient[Post]

func (c *lenicClient) GetFeed(ctx context.Context, in *GetFeedRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Post], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lenic_ServiceDesc.Streams[7], Lenic_GetFeed_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetFeedRequest, Post]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetFeedClient = grpc.ServerStreamingClient[Post]

func (c *lenicClient) RatePostUp(ctx context.Context, in *PostRating, opts ...grpc.CallOption) (*RatePostUpResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RatePostUpResponse)
	err := c.cc.Invoke(ctx, Lenic_RatePostUp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) RatePostDown(ctx context.Context, in *PostRating, opts ...grpc.CallOption) (*RatePostDownResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RatePostDownResponse)
	err := c.cc.Invoke(ctx, Lenic_RatePostDown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) UpdatePost(ctx context.Context, in *Post, opts ...grpc.CallOption) (*UpdatePostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdatePostResponse)
	err := c.cc.Invoke(ctx, Lenic_UpdatePost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) DeletePost(ctx context.Context, in *DeletePostRequest, opts ...grpc.CallOption) (*DeletePostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeletePostResponse)
	err := c.cc.Invoke(ctx, Lenic_DeletePost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) CreateComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*CreateCommentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCommentResponse)
	err := c.cc.Invoke(ctx, Lenic_CreateComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) GetComment(ctx context.Context, in *GetCommentRequest, opts ...grpc.CallOption) (*Comment, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Comment)
	err := c.cc.Invoke(ctx, Lenic_GetComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) GetCommentsFromPost(ctx context.Context, in *GetCommentsFromPostRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Comment], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lenic_ServiceDesc.Streams[8], Lenic_GetCommentsFromPost_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetCommentsFromPostRequest, Comment]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetCommentsFromPostClient = grpc.ServerStreamingClient[Comment]

func (c *lenicClient) RateCommentUp(ctx context.Context, in *CommentRating, opts ...grpc.CallOption) (*RateCommentUpResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RateCommentUpResponse)
	err := c.cc.Invoke(ctx, Lenic_RateCommentUp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) RateCommentDown(ctx context.Context, in *CommentRating, opts ...grpc.CallOption) (*RateCommentDownResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RateCommentDownResponse)
	err := c.cc.Invoke(ctx, Lenic_RateCommentDown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) UpdateComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*UpdateCommentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateCommentResponse)
	err := c.cc.Invoke(ctx, Lenic_UpdateComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) DeleteComment(ctx context.Context, in *DeleteCommentRequest, opts ...grpc.CallOption) (*DeleteCommentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteCommentResponse)
	err := c.cc.Invoke(ctx, Lenic_DeleteComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LenicServer is the server API for Lenic service.
// All implementations must embed UnimplementedLenicServer
// for forward compatibility.
type LenicServer interface {
	ActivateUser(context.Context, *ActivateUserRequest) (*ActivateUserResponse, error)
	GetUser(context.Context, *GetUserRequest) (*User, error)
	SearchUsers(*SearchUsersRequest, grpc.ServerStreamingServer[User]) error
	GetUserFollowers(*GetUserFollowersRequest, grpc.ServerStreamingServer[User]) error
	GetUserFollowing(*GetUserFollowingRequest, grpc.ServerStreamingServer[User]) error
	FollowUser(context.Context, *Follow) (*FollowUserResponse, error)
	AcceptFollow(context.Context, *Follow) (*AcceptFollowResponse, error)
	UnfollowUser(context.Context, *Follow) (*UnfollowUserResponse, error)
	UpdateUserPass(context.Context, *User) (*UpdateUserPassResponse, error)
	DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error)
	StartConversation(context.Context, *Conversation) (*StartConversationResponse, error)
	GetUserConversations(*GetUserConversationsRequest, grpc.ServerStreamingServer[Conversation]) error
	ReadConversation(context.Context, *ReadConversationRequest) (*ReadConversationResponse, error)
	SendDM(context.Context, *DM) (*SendDMResponse, error)
	GetConversationDMs(*GetConversationDMsRequest, grpc.ServerStreamingServer[DM]) error
	CreatePost(context.Context, *Post) (*CreatePostResponse, error)
	GetPost(context.Context, *GetPostRequest) (*Post, error)
	GetUserPosts(*GetUserPostsRequest, grpc.ServerStreamingServer[Post]) error
	GetUserPublicPosts(*GetUserPublicPostsRequest, grpc.ServerStreamingServer[Post]) error
	GetFeed(*GetFeedRequest, grpc.ServerStreamingServer[Post]) error
	RatePostUp(context.Context, *PostRating) (*RatePostUpResponse, error)
	RatePostDown(context.Context, *PostRating) (*RatePostDownResponse, error)
	UpdatePost(context.Context, *Post) (*UpdatePostResponse, error)
	DeletePost(context.Context, *DeletePostRequest) (*DeletePostResponse, error)
	CreateComment(context.Context, *Comment) (*CreateCommentResponse, error)
	GetComment(context.Context, *GetCommentRequest) (*Comment, error)
	GetCommentsFromPost(*GetCommentsFromPostRequest, grpc.ServerStreamingServer[Comment]) error
	RateCommentUp(context.Context, *CommentRating) (*RateCommentUpResponse, error)
	RateCommentDown(context.Context, *CommentRating) (*RateCommentDownResponse, error)
	UpdateComment(context.Context, *Comment) (*UpdateCommentResponse, error)
	DeleteComment(context.Context, *DeleteCommentRequest) (*DeleteCommentResponse, error)
	mustEmbedUnimplementedLenicServer()
}

// UnimplementedLenicServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLenicServer struct{}

func (UnimplementedLenicServer) ActivateUser(context.Context, *ActivateUserRequest) (*ActivateUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateUser not implemented")
}
func (UnimplementedLenicServer) GetUser(context.Context, *GetUserRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedLenicServer) SearchUsers(*SearchUsersRequest, grpc.ServerStreamingServer[User]) error {
	return status.Errorf(codes.Unimplemented, "method SearchUsers not implemented")
}
func (UnimplementedLenicServer) GetUserFollowers(*GetUserFollowersRequest, grpc.ServerStreamingServer[User]) error {
	return status.Errorf(codes.Unimplemented, "method GetUserFollowers not implemented")
}
func (UnimplementedLenicServer) GetUserFollowing(*GetUserFollowingRequest, grpc.ServerStreamingServer[User]) error {
	return status.Errorf(codes.Unimplemented, "method GetUserFollowing not implemented")
}
func (UnimplementedLenicServer) FollowUser(context.Context, *Follow) (*FollowUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FollowUser not implemented")
}
func (UnimplementedLenicServer) AcceptFollow(context.Context, *Follow) (*AcceptFollowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcceptFollow not implemented")
}
func (UnimplementedLenicServer) UnfollowUser(context.Context, *Follow) (*UnfollowUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnfollowUser not implemented")
}
func (UnimplementedLenicServer) UpdateUserPass(context.Context, *User) (*UpdateUserPassResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserPass not implemented")
}
func (UnimplementedLenicServer) DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedLenicServer) StartConversation(context.Context, *Conversation) (*StartConversationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartConversation not implemented")
}
func (UnimplementedLenicServer) GetUserConversations(*GetUserConversationsRequest, grpc.ServerStreamingServer[Conversation]) error {
	return status.Errorf(codes.Unimplemented, "method GetUserConversations not implemented")
}
func (UnimplementedLenicServer) ReadConversation(context.Context, *ReadConversationRequest) (*ReadConversationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadConversation not implemented")
}
func (UnimplementedLenicServer) SendDM(context.Context, *DM) (*SendDMResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendDM not implemented")
}
func (UnimplementedLenicServer) GetConversationDMs(*GetConversationDMsRequest, grpc.ServerStreamingServer[DM]) error {
	return status.Errorf(codes.Unimplemented, "method GetConversationDMs not implemented")
}
func (UnimplementedLenicServer) CreatePost(context.Context, *Post) (*CreatePostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePost not implemented")
}
func (UnimplementedLenicServer) GetPost(context.Context, *GetPostRequest) (*Post, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPost not implemented")
}
func (UnimplementedLenicServer) GetUserPosts(*GetUserPostsRequest, grpc.ServerStreamingServer[Post]) error {
	return status.Errorf(codes.Unimplemented, "method GetUserPosts not implemented")
}
func (UnimplementedLenicServer) GetUserPublicPosts(*GetUserPublicPostsRequest, grpc.ServerStreamingServer[Post]) error {
	return status.Errorf(codes.Unimplemented, "method GetUserPublicPosts not implemented")
}
func (UnimplementedLenicServer) GetFeed(*GetFeedRequest, grpc.ServerStreamingServer[Post]) error {
	return status.Errorf(codes.Unimplemented, "method GetFeed not implemented")
}
func (UnimplementedLenicServer) RatePostUp(context.Context, *PostRating) (*RatePostUpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RatePostUp not implemented")
}
func (UnimplementedLenicServer) RatePostDown(context.Context, *PostRating) (*RatePostDownResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RatePostDown not implemented")
}
func (UnimplementedLenicServer) UpdatePost(context.Context, *Post) (*UpdatePostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePost not implemented")
}
func (UnimplementedLenicServer) DeletePost(context.Context, *DeletePostRequest) (*DeletePostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePost not implemented")
}
func (UnimplementedLenicServer) CreateComment(context.Context, *Comment) (*CreateCommentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateComment not implemented")
}
func (UnimplementedLenicServer) GetComment(context.Context, *GetCommentRequest) (*Comment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetComment not implemented")
}
func (UnimplementedLenicServer) GetCommentsFromPost(*GetCommentsFromPostRequest, grpc.ServerStreamingServer[Comment]) error {
	return status.Errorf(codes.Unimplemented, "method GetCommentsFromPost not implemented")
}
func (UnimplementedLenicServer) RateCommentUp(context.Context, *CommentRating) (*RateCommentUpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RateCommentUp not implemented")
}
func (UnimplementedLenicServer) RateCommentDown(context.Context, *CommentRating) (*RateCommentDownResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RateCommentDown not implemented")
}
func (UnimplementedLenicServer) UpdateComment(context.Context, *Comment) (*UpdateCommentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateComment not implemented")
}
func (UnimplementedLenicServer) DeleteComment(context.Context, *DeleteCommentRequest) (*DeleteCommentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteComment not implemented")
}
func (UnimplementedLenicServer) mustEmbedUnimplementedLenicServer() {}
func (UnimplementedLenicServer) testEmbeddedByValue()               {}

// UnsafeLenicServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LenicServer will
// result in compilation errors.
type UnsafeLenicServer interface {
	mustEmbedUnimplementedLenicServer()
}

func RegisterLenicServer(s grpc.ServiceRegistrar, srv LenicServer) {
	// If the following call pancis, it indicates UnimplementedLenicServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Lenic_ServiceDesc, srv)
}

func _Lenic_ActivateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).ActivateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_ActivateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).ActivateUser(ctx, req.(*ActivateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).GetUser(ctx, req.(*GetUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_SearchUsers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchUsersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LenicServer).SearchUsers(m, &grpc.GenericServerStream[SearchUsersRequest, User]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_SearchUsersServer = grpc.ServerStreamingServer[User]

func _Lenic_GetUserFollowers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetUserFollowersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LenicServer).GetUserFollowers(m, &grpc.GenericServerStream[GetUserFollowersRequest, User]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserFollowersServer = grpc.ServerStreamingServer[User]

func _Lenic_GetUserFollowing_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetUserFollowingRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LenicServer).GetUserFollowing(m, &grpc.GenericServerStream[GetUserFollowingRequest, User]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserFollowingServer = grpc.ServerStreamingServer[User]

func _Lenic_FollowUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Follow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).FollowUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_FollowUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).FollowUser(ctx, req.(*Follow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_AcceptFollow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Follow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).AcceptFollow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_AcceptFollow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).AcceptFollow(ctx, req.(*Follow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_UnfollowUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Follow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).UnfollowUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_UnfollowUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).UnfollowUser(ctx, req.(*Follow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_UpdateUserPass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).UpdateUserPass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_UpdateUserPass_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).UpdateUserPass(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).DeleteUser(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_StartConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Conversation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).StartConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_StartConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).StartConversation(ctx, req.(*Conversation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_GetUserConversations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetUserConversationsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LenicServer).GetUserConversations(m, &grpc.GenericServerStream[GetUserConversationsRequest, Conversation]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserConversationsServer = grpc.ServerStreamingServer[Conversation]

func _Lenic_ReadConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).ReadConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_ReadConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).ReadConversation(ctx, req.(*ReadConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_SendDM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DM)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).SendDM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_SendDM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).SendDM(ctx, req.(*DM))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_GetConversationDMs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetConversationDMsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LenicServer).GetConversationDMs(m, &grpc.GenericServerStream[GetConversationDMsRequest, DM]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetConversationDMsServer = grpc.ServerStreamingServer[DM]

func _Lenic_CreatePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Post)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).CreatePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_CreatePost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).CreatePost(ctx, req.(*Post))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_GetPost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).GetPost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_GetPost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).GetPost(ctx, req.(*GetPostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_GetUserPosts_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetUserPostsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LenicServer).GetUserPosts(m, &grpc.GenericServerStream[GetUserPostsRequest, Post]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserPostsServer = grpc.ServerStreamingServer[Post]

func _Lenic_GetUserPublicPosts_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetUserPublicPostsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LenicServer).GetUserPublicPosts(m, &grpc.GenericServerStream[GetUserPublicPostsRequest, Post]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserPublicPostsServer = grpc.ServerStreamingServer[Post]

func _Lenic_GetFeed_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetFeedRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LenicServer).GetFeed(m, &grpc.GenericServerStream[GetFeedRequest, Post]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetFeedServer = grpc.ServerStreamingServer[Post]

func _Lenic_RatePostUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PostRating)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).RatePostUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_RatePostUp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).RatePostUp(ctx, req.(*PostRating))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_RatePostDown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PostRating)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).RatePostDown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_RatePostDown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).RatePostDown(ctx, req.(*PostRating))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_UpdatePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Post)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).UpdatePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_UpdatePost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).UpdatePost(ctx, req.(*Post))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_DeletePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).DeletePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_DeletePost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).DeletePost(ctx, req.(*DeletePostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_CreateComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).CreateComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_CreateComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).CreateComment(ctx, req.(*Comment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_GetComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).GetComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_GetComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).GetComment(ctx, req.(*GetCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_GetCommentsFromPost_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetCommentsFromPostRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LenicServer).GetCommentsFromPost(m, &grpc.GenericServerStream[GetCommentsFromPostRequest, Comment]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetCommentsFromPostServer = grpc.ServerStreamingServer[Comment]

func _Lenic_RateCommentUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommentRating)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).RateCommentUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_RateCommentUp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).RateCommentUp(ctx, req.(*CommentRating))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_RateCommentDown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommentRating)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).RateCommentDown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_RateCommentDown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).RateCommentDown(ctx, req.(*CommentRating))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_UpdateComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).UpdateComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_UpdateComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).UpdateComment(ctx, req.(*Comment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_DeleteComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).DeleteComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_DeleteComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).DeleteComment(ctx, req.(*DeleteCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Lenic_ServiceDesc is the grpc.ServiceDesc for Lenic service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Lenic_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lenic.Lenic",
	HandlerType: (*LenicServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ActivateUser",
			Handler:    _Lenic_ActivateUser_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _Lenic_GetUser_Handler,
		},
		{
			MethodName: "FollowUser",
			Handler:    _Lenic_FollowUser_Handler,
		},
		{
			MethodName: "AcceptFollow",
			Handler:    _Lenic_AcceptFollow_Handler,
		},
		{
			MethodName: "UnfollowUser",
			Handler:    _Lenic_UnfollowUser_Handler,
		},
		{
			MethodName: "UpdateUserPass",
			Handler:    _Lenic_UpdateUserPass_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _Lenic_DeleteUser_Handler,
		},
		{
			MethodName: "StartConversation",
			Handler:    _Lenic_StartConversation_Handler,
		},
		{
			MethodName: "ReadConversation",
			Handler:    _Lenic_ReadConversation_Handler,
		},
		{
			MethodName: "SendDM",
			Handler:    _Lenic_SendDM_Handler,
		},
		{
			MethodName: "CreatePost",
			Handler:    _Lenic_CreatePost_Handler,
		},
		{
			MethodName: "GetPost",
			Handler:    _Lenic_GetPost_Handler,
		},
		{
			MethodName: "RatePostUp",
			Handler:    _Lenic_RatePostUp_Handler,
		},
		{
			MethodName: "RatePostDown",
			Handler:    _Lenic_RatePostDown_Handler,
		},
		{
			MethodName: "UpdatePost",
			Handler:    _Lenic_UpdatePost_Handler,
		},
		{
			MethodName: "DeletePost",
			Handler:    _Lenic_DeletePost_Handler,
		},
		{
			MethodName: "CreateComment",
			Handler:    _Lenic_CreateComment_Handler,
		},
		{
			MethodName: "GetComment",
			Handler:    _Lenic_GetComment_Handler,
		},
		{
			MethodName: "RateCommentUp",
			Handler:    _Lenic_RateCommentUp_Handler,
		},
		{
			MethodName: "RateCommentDown",
			Handler:    _Lenic_RateCommentDown_Handler,
		},
		{
			MethodName: "UpdateComment",
			Handler:    _Lenic_UpdateComment_Handler,
		},
		{
			MethodName: "DeleteComment",
			Handler:    _Lenic_DeleteComment_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SearchUsers",
			Handler:       _Lenic_SearchUsers_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetUserFollowers",
			Handler:       _Lenic_GetUserFollowers_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetUserFollowing",
			Handler:       _Lenic_GetUserFollowing_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetUserConversations",
			Handler:       _Lenic_GetUserConversations_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetConversationDMs",
			Handler:       _Lenic_GetConversationDMs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetUserPosts",
			Handler:       _Lenic_GetUserPosts_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetUserPublicPosts",
			Handler:       _Lenic_GetUserPublicPosts_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetFeed",
			Handler:       _Lenic_GetFeed_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetCommentsFromPost",
			Handler:       _Lenic_GetCommentsFromPost_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "lenic.proto",
}
