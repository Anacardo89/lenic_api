// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.30.0--dev
// source: lenic.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AuthService_Login_FullMethodName = "/lenic.AuthService/Login"
)

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthServiceClient interface {
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
}

type authServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, AuthService_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility.
type AuthServiceServer interface {
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthServiceServer struct{}

func (UnimplementedAuthServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {}
func (UnimplementedAuthServiceServer) testEmbeddedByValue()                     {}

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
	mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) {
	// If the following call pancis, it indicates UnimplementedAuthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuthService_ServiceDesc, srv)
}

func _AuthService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lenic.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _AuthService_Login_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lenic.proto",
}

const (
	Lenic_CreateUser_FullMethodName           = "/lenic.Lenic/CreateUser"
	Lenic_ActivateUser_FullMethodName         = "/lenic.Lenic/ActivateUser"
	Lenic_GetUser_FullMethodName              = "/lenic.Lenic/GetUser"
	Lenic_SearchUsers_FullMethodName          = "/lenic.Lenic/SearchUsers"
	Lenic_TagUser_FullMethodName              = "/lenic.Lenic/TagUser"
	Lenic_GetUserFollowers_FullMethodName     = "/lenic.Lenic/GetUserFollowers"
	Lenic_GetUserFollowing_FullMethodName     = "/lenic.Lenic/GetUserFollowing"
	Lenic_FollowUser_FullMethodName           = "/lenic.Lenic/FollowUser"
	Lenic_AcceptFollow_FullMethodName         = "/lenic.Lenic/AcceptFollow"
	Lenic_UnfollowUser_FullMethodName         = "/lenic.Lenic/UnfollowUser"
	Lenic_UpdateUserPass_FullMethodName       = "/lenic.Lenic/UpdateUserPass"
	Lenic_UpdateUserProfilePic_FullMethodName = "/lenic.Lenic/UpdateUserProfilePic"
	Lenic_DeleteUser_FullMethodName           = "/lenic.Lenic/DeleteUser"
	Lenic_StartConversation_FullMethodName    = "/lenic.Lenic/StartConversation"
	Lenic_GetUserConversations_FullMethodName = "/lenic.Lenic/GetUserConversations"
	Lenic_ReadConversation_FullMethodName     = "/lenic.Lenic/ReadConversation"
	Lenic_SendDM_FullMethodName               = "/lenic.Lenic/SendDM"
	Lenic_GetConversationDMs_FullMethodName   = "/lenic.Lenic/GetConversationDMs"
	Lenic_CreateNotification_FullMethodName   = "/lenic.Lenic/CreateNotification"
	Lenic_GetUserNotifications_FullMethodName = "/lenic.Lenic/GetUserNotifications"
	Lenic_ReadNotification_FullMethodName     = "/lenic.Lenic/ReadNotification"
	Lenic_CreatePost_FullMethodName           = "/lenic.Lenic/CreatePost"
	Lenic_GetPost_FullMethodName              = "/lenic.Lenic/GetPost"
	Lenic_GetPostPic_FullMethodName           = "/lenic.Lenic/GetPostPic"
	Lenic_GetUserPosts_FullMethodName         = "/lenic.Lenic/GetUserPosts"
	Lenic_GetUserPublicPosts_FullMethodName   = "/lenic.Lenic/GetUserPublicPosts"
	Lenic_RatePost_FullMethodName             = "/lenic.Lenic/RatePost"
	Lenic_UpdatePost_FullMethodName           = "/lenic.Lenic/UpdatePost"
	Lenic_DeletePost_FullMethodName           = "/lenic.Lenic/DeletePost"
	Lenic_CreateComment_FullMethodName        = "/lenic.Lenic/CreateComment"
	Lenic_GetComment_FullMethodName           = "/lenic.Lenic/GetComment"
	Lenic_GetCommentsFromPost_FullMethodName  = "/lenic.Lenic/GetCommentsFromPost"
	Lenic_RateComment_FullMethodName          = "/lenic.Lenic/RateComment"
	Lenic_UpdateComment_FullMethodName        = "/lenic.Lenic/UpdateComment"
	Lenic_DeleteComment_FullMethodName        = "/lenic.Lenic/DeleteComment"
)

// LenicClient is the client API for Lenic service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LenicClient interface {
	CreateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*wrapperspb.Int32Value, error)
	ActivateUser(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	GetUser(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*User, error)
	SearchUsers(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (grpc.ServerStreamingClient[User], error)
	TagUser(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	GetUserFollowers(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (grpc.ServerStreamingClient[User], error)
	GetUserFollowing(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (grpc.ServerStreamingClient[User], error)
	FollowUser(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	AcceptFollow(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	UnfollowUser(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	UpdateUserPass(ctx context.Context, in *User, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	UpdateUserProfilePic(ctx context.Context, in *User, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	DeleteUser(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	StartConversation(ctx context.Context, in *Conversation, opts ...grpc.CallOption) (*wrapperspb.Int32Value, error)
	GetUserConversations(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Conversation], error)
	ReadConversation(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	SendDM(ctx context.Context, in *DM, opts ...grpc.CallOption) (*wrapperspb.Int32Value, error)
	GetConversationDMs(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DM], error)
	CreateNotification(ctx context.Context, in *Notification, opts ...grpc.CallOption) (*wrapperspb.Int32Value, error)
	GetUserNotifications(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Notification], error)
	ReadNotification(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (*wrapperspb.Int32Value, error)
	CreatePost(ctx context.Context, in *Post, opts ...grpc.CallOption) (*wrapperspb.Int32Value, error)
	GetPost(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*Post, error)
	GetPostPic(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*Post, error)
	GetUserPosts(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Post], error)
	GetUserPublicPosts(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Post], error)
	RatePost(ctx context.Context, in *PostRating, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	UpdatePost(ctx context.Context, in *Post, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	DeletePost(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	CreateComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*wrapperspb.Int32Value, error)
	GetComment(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (*Comment, error)
	GetCommentsFromPost(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Comment], error)
	RateComment(ctx context.Context, in *CommentRating, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	UpdateComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	DeleteComment(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
}

type lenicClient struct {
	cc grpc.ClientConnInterface
}

func NewLenicClient(cc grpc.ClientConnInterface) LenicClient {
	return &lenicClient{cc}
}

func (c *lenicClient) CreateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*wrapperspb.Int32Value, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.Int32Value)
	err := c.cc.Invoke(ctx, Lenic_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) ActivateUser(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, Lenic_ActivateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) GetUser(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, Lenic_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) SearchUsers(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (grpc.ServerStreamingClient[User], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lenic_ServiceDesc.Streams[0], Lenic_SearchUsers_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[wrapperspb.StringValue, User]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_SearchUsersClient = grpc.ServerStreamingClient[User]

func (c *lenicClient) TagUser(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, Lenic_TagUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) GetUserFollowers(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (grpc.ServerStreamingClient[User], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lenic_ServiceDesc.Streams[1], Lenic_GetUserFollowers_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[wrapperspb.Int32Value, User]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserFollowersClient = grpc.ServerStreamingClient[User]

func (c *lenicClient) GetUserFollowing(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (grpc.ServerStreamingClient[User], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lenic_ServiceDesc.Streams[2], Lenic_GetUserFollowing_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[wrapperspb.Int32Value, User]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserFollowingClient = grpc.ServerStreamingClient[User]

func (c *lenicClient) FollowUser(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, Lenic_FollowUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) AcceptFollow(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, Lenic_AcceptFollow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) UnfollowUser(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, Lenic_UnfollowUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) UpdateUserPass(ctx context.Context, in *User, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, Lenic_UpdateUserPass_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) UpdateUserProfilePic(ctx context.Context, in *User, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, Lenic_UpdateUserProfilePic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) DeleteUser(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, Lenic_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) StartConversation(ctx context.Context, in *Conversation, opts ...grpc.CallOption) (*wrapperspb.Int32Value, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.Int32Value)
	err := c.cc.Invoke(ctx, Lenic_StartConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) GetUserConversations(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Conversation], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lenic_ServiceDesc.Streams[3], Lenic_GetUserConversations_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[wrapperspb.StringValue, Conversation]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserConversationsClient = grpc.ServerStreamingClient[Conversation]

func (c *lenicClient) ReadConversation(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, Lenic_ReadConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) SendDM(ctx context.Context, in *DM, opts ...grpc.CallOption) (*wrapperspb.Int32Value, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.Int32Value)
	err := c.cc.Invoke(ctx, Lenic_SendDM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) GetConversationDMs(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DM], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lenic_ServiceDesc.Streams[4], Lenic_GetConversationDMs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[wrapperspb.Int32Value, DM]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetConversationDMsClient = grpc.ServerStreamingClient[DM]

func (c *lenicClient) CreateNotification(ctx context.Context, in *Notification, opts ...grpc.CallOption) (*wrapperspb.Int32Value, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.Int32Value)
	err := c.cc.Invoke(ctx, Lenic_CreateNotification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) GetUserNotifications(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Notification], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lenic_ServiceDesc.Streams[5], Lenic_GetUserNotifications_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[wrapperspb.StringValue, Notification]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserNotificationsClient = grpc.ServerStreamingClient[Notification]

func (c *lenicClient) ReadNotification(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (*wrapperspb.Int32Value, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.Int32Value)
	err := c.cc.Invoke(ctx, Lenic_ReadNotification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) CreatePost(ctx context.Context, in *Post, opts ...grpc.CallOption) (*wrapperspb.Int32Value, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.Int32Value)
	err := c.cc.Invoke(ctx, Lenic_CreatePost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) GetPost(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*Post, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Post)
	err := c.cc.Invoke(ctx, Lenic_GetPost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) GetPostPic(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*Post, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Post)
	err := c.cc.Invoke(ctx, Lenic_GetPostPic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) GetUserPosts(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Post], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lenic_ServiceDesc.Streams[6], Lenic_GetUserPosts_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[wrapperspb.StringValue, Post]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserPostsClient = grpc.ServerStreamingClient[Post]

func (c *lenicClient) GetUserPublicPosts(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Post], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lenic_ServiceDesc.Streams[7], Lenic_GetUserPublicPosts_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[wrapperspb.StringValue, Post]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserPublicPostsClient = grpc.ServerStreamingClient[Post]

func (c *lenicClient) RatePost(ctx context.Context, in *PostRating, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, Lenic_RatePost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) UpdatePost(ctx context.Context, in *Post, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, Lenic_UpdatePost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) DeletePost(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, Lenic_DeletePost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) CreateComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*wrapperspb.Int32Value, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.Int32Value)
	err := c.cc.Invoke(ctx, Lenic_CreateComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) GetComment(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (*Comment, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Comment)
	err := c.cc.Invoke(ctx, Lenic_GetComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) GetCommentsFromPost(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Comment], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lenic_ServiceDesc.Streams[8], Lenic_GetCommentsFromPost_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[wrapperspb.StringValue, Comment]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetCommentsFromPostClient = grpc.ServerStreamingClient[Comment]

func (c *lenicClient) RateComment(ctx context.Context, in *CommentRating, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, Lenic_RateComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) UpdateComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, Lenic_UpdateComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lenicClient) DeleteComment(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, Lenic_DeleteComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LenicServer is the server API for Lenic service.
// All implementations must embed UnimplementedLenicServer
// for forward compatibility.
type LenicServer interface {
	CreateUser(context.Context, *User) (*wrapperspb.Int32Value, error)
	ActivateUser(context.Context, *wrapperspb.StringValue) (*wrapperspb.StringValue, error)
	GetUser(context.Context, *wrapperspb.StringValue) (*User, error)
	SearchUsers(*wrapperspb.StringValue, grpc.ServerStreamingServer[User]) error
	TagUser(context.Context, *Tag) (*wrapperspb.StringValue, error)
	GetUserFollowers(*wrapperspb.Int32Value, grpc.ServerStreamingServer[User]) error
	GetUserFollowing(*wrapperspb.Int32Value, grpc.ServerStreamingServer[User]) error
	FollowUser(context.Context, *Follow) (*wrapperspb.StringValue, error)
	AcceptFollow(context.Context, *Follow) (*wrapperspb.StringValue, error)
	UnfollowUser(context.Context, *Follow) (*wrapperspb.StringValue, error)
	UpdateUserPass(context.Context, *User) (*wrapperspb.StringValue, error)
	UpdateUserProfilePic(context.Context, *User) (*wrapperspb.StringValue, error)
	DeleteUser(context.Context, *wrapperspb.StringValue) (*wrapperspb.StringValue, error)
	StartConversation(context.Context, *Conversation) (*wrapperspb.Int32Value, error)
	GetUserConversations(*wrapperspb.StringValue, grpc.ServerStreamingServer[Conversation]) error
	ReadConversation(context.Context, *wrapperspb.Int32Value) (*wrapperspb.StringValue, error)
	SendDM(context.Context, *DM) (*wrapperspb.Int32Value, error)
	GetConversationDMs(*wrapperspb.Int32Value, grpc.ServerStreamingServer[DM]) error
	CreateNotification(context.Context, *Notification) (*wrapperspb.Int32Value, error)
	GetUserNotifications(*wrapperspb.StringValue, grpc.ServerStreamingServer[Notification]) error
	ReadNotification(context.Context, *wrapperspb.Int32Value) (*wrapperspb.Int32Value, error)
	CreatePost(context.Context, *Post) (*wrapperspb.Int32Value, error)
	GetPost(context.Context, *wrapperspb.StringValue) (*Post, error)
	GetPostPic(context.Context, *wrapperspb.StringValue) (*Post, error)
	GetUserPosts(*wrapperspb.StringValue, grpc.ServerStreamingServer[Post]) error
	GetUserPublicPosts(*wrapperspb.StringValue, grpc.ServerStreamingServer[Post]) error
	RatePost(context.Context, *PostRating) (*wrapperspb.StringValue, error)
	UpdatePost(context.Context, *Post) (*wrapperspb.StringValue, error)
	DeletePost(context.Context, *wrapperspb.StringValue) (*wrapperspb.StringValue, error)
	CreateComment(context.Context, *Comment) (*wrapperspb.Int32Value, error)
	GetComment(context.Context, *wrapperspb.Int32Value) (*Comment, error)
	GetCommentsFromPost(*wrapperspb.StringValue, grpc.ServerStreamingServer[Comment]) error
	RateComment(context.Context, *CommentRating) (*wrapperspb.StringValue, error)
	UpdateComment(context.Context, *Comment) (*wrapperspb.StringValue, error)
	DeleteComment(context.Context, *wrapperspb.StringValue) (*wrapperspb.StringValue, error)
	mustEmbedUnimplementedLenicServer()
}

// UnimplementedLenicServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLenicServer struct{}

func (UnimplementedLenicServer) CreateUser(context.Context, *User) (*wrapperspb.Int32Value, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedLenicServer) ActivateUser(context.Context, *wrapperspb.StringValue) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateUser not implemented")
}
func (UnimplementedLenicServer) GetUser(context.Context, *wrapperspb.StringValue) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedLenicServer) SearchUsers(*wrapperspb.StringValue, grpc.ServerStreamingServer[User]) error {
	return status.Errorf(codes.Unimplemented, "method SearchUsers not implemented")
}
func (UnimplementedLenicServer) TagUser(context.Context, *Tag) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TagUser not implemented")
}
func (UnimplementedLenicServer) GetUserFollowers(*wrapperspb.Int32Value, grpc.ServerStreamingServer[User]) error {
	return status.Errorf(codes.Unimplemented, "method GetUserFollowers not implemented")
}
func (UnimplementedLenicServer) GetUserFollowing(*wrapperspb.Int32Value, grpc.ServerStreamingServer[User]) error {
	return status.Errorf(codes.Unimplemented, "method GetUserFollowing not implemented")
}
func (UnimplementedLenicServer) FollowUser(context.Context, *Follow) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FollowUser not implemented")
}
func (UnimplementedLenicServer) AcceptFollow(context.Context, *Follow) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcceptFollow not implemented")
}
func (UnimplementedLenicServer) UnfollowUser(context.Context, *Follow) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnfollowUser not implemented")
}
func (UnimplementedLenicServer) UpdateUserPass(context.Context, *User) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserPass not implemented")
}
func (UnimplementedLenicServer) UpdateUserProfilePic(context.Context, *User) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserProfilePic not implemented")
}
func (UnimplementedLenicServer) DeleteUser(context.Context, *wrapperspb.StringValue) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedLenicServer) StartConversation(context.Context, *Conversation) (*wrapperspb.Int32Value, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartConversation not implemented")
}
func (UnimplementedLenicServer) GetUserConversations(*wrapperspb.StringValue, grpc.ServerStreamingServer[Conversation]) error {
	return status.Errorf(codes.Unimplemented, "method GetUserConversations not implemented")
}
func (UnimplementedLenicServer) ReadConversation(context.Context, *wrapperspb.Int32Value) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadConversation not implemented")
}
func (UnimplementedLenicServer) SendDM(context.Context, *DM) (*wrapperspb.Int32Value, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendDM not implemented")
}
func (UnimplementedLenicServer) GetConversationDMs(*wrapperspb.Int32Value, grpc.ServerStreamingServer[DM]) error {
	return status.Errorf(codes.Unimplemented, "method GetConversationDMs not implemented")
}
func (UnimplementedLenicServer) CreateNotification(context.Context, *Notification) (*wrapperspb.Int32Value, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNotification not implemented")
}
func (UnimplementedLenicServer) GetUserNotifications(*wrapperspb.StringValue, grpc.ServerStreamingServer[Notification]) error {
	return status.Errorf(codes.Unimplemented, "method GetUserNotifications not implemented")
}
func (UnimplementedLenicServer) ReadNotification(context.Context, *wrapperspb.Int32Value) (*wrapperspb.Int32Value, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadNotification not implemented")
}
func (UnimplementedLenicServer) CreatePost(context.Context, *Post) (*wrapperspb.Int32Value, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePost not implemented")
}
func (UnimplementedLenicServer) GetPost(context.Context, *wrapperspb.StringValue) (*Post, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPost not implemented")
}
func (UnimplementedLenicServer) GetPostPic(context.Context, *wrapperspb.StringValue) (*Post, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPostPic not implemented")
}
func (UnimplementedLenicServer) GetUserPosts(*wrapperspb.StringValue, grpc.ServerStreamingServer[Post]) error {
	return status.Errorf(codes.Unimplemented, "method GetUserPosts not implemented")
}
func (UnimplementedLenicServer) GetUserPublicPosts(*wrapperspb.StringValue, grpc.ServerStreamingServer[Post]) error {
	return status.Errorf(codes.Unimplemented, "method GetUserPublicPosts not implemented")
}
func (UnimplementedLenicServer) RatePost(context.Context, *PostRating) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RatePost not implemented")
}
func (UnimplementedLenicServer) UpdatePost(context.Context, *Post) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePost not implemented")
}
func (UnimplementedLenicServer) DeletePost(context.Context, *wrapperspb.StringValue) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePost not implemented")
}
func (UnimplementedLenicServer) CreateComment(context.Context, *Comment) (*wrapperspb.Int32Value, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateComment not implemented")
}
func (UnimplementedLenicServer) GetComment(context.Context, *wrapperspb.Int32Value) (*Comment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetComment not implemented")
}
func (UnimplementedLenicServer) GetCommentsFromPost(*wrapperspb.StringValue, grpc.ServerStreamingServer[Comment]) error {
	return status.Errorf(codes.Unimplemented, "method GetCommentsFromPost not implemented")
}
func (UnimplementedLenicServer) RateComment(context.Context, *CommentRating) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RateComment not implemented")
}
func (UnimplementedLenicServer) UpdateComment(context.Context, *Comment) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateComment not implemented")
}
func (UnimplementedLenicServer) DeleteComment(context.Context, *wrapperspb.StringValue) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteComment not implemented")
}
func (UnimplementedLenicServer) mustEmbedUnimplementedLenicServer() {}
func (UnimplementedLenicServer) testEmbeddedByValue()               {}

// UnsafeLenicServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LenicServer will
// result in compilation errors.
type UnsafeLenicServer interface {
	mustEmbedUnimplementedLenicServer()
}

func RegisterLenicServer(s grpc.ServiceRegistrar, srv LenicServer) {
	// If the following call pancis, it indicates UnimplementedLenicServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Lenic_ServiceDesc, srv)
}

func _Lenic_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).CreateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_ActivateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).ActivateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_ActivateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).ActivateUser(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).GetUser(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_SearchUsers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(wrapperspb.StringValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LenicServer).SearchUsers(m, &grpc.GenericServerStream[wrapperspb.StringValue, User]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_SearchUsersServer = grpc.ServerStreamingServer[User]

func _Lenic_TagUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).TagUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_TagUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).TagUser(ctx, req.(*Tag))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_GetUserFollowers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(wrapperspb.Int32Value)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LenicServer).GetUserFollowers(m, &grpc.GenericServerStream[wrapperspb.Int32Value, User]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserFollowersServer = grpc.ServerStreamingServer[User]

func _Lenic_GetUserFollowing_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(wrapperspb.Int32Value)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LenicServer).GetUserFollowing(m, &grpc.GenericServerStream[wrapperspb.Int32Value, User]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserFollowingServer = grpc.ServerStreamingServer[User]

func _Lenic_FollowUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Follow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).FollowUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_FollowUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).FollowUser(ctx, req.(*Follow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_AcceptFollow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Follow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).AcceptFollow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_AcceptFollow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).AcceptFollow(ctx, req.(*Follow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_UnfollowUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Follow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).UnfollowUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_UnfollowUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).UnfollowUser(ctx, req.(*Follow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_UpdateUserPass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).UpdateUserPass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_UpdateUserPass_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).UpdateUserPass(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_UpdateUserProfilePic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).UpdateUserProfilePic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_UpdateUserProfilePic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).UpdateUserProfilePic(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).DeleteUser(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_StartConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Conversation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).StartConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_StartConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).StartConversation(ctx, req.(*Conversation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_GetUserConversations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(wrapperspb.StringValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LenicServer).GetUserConversations(m, &grpc.GenericServerStream[wrapperspb.StringValue, Conversation]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserConversationsServer = grpc.ServerStreamingServer[Conversation]

func _Lenic_ReadConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.Int32Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).ReadConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_ReadConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).ReadConversation(ctx, req.(*wrapperspb.Int32Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_SendDM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DM)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).SendDM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_SendDM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).SendDM(ctx, req.(*DM))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_GetConversationDMs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(wrapperspb.Int32Value)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LenicServer).GetConversationDMs(m, &grpc.GenericServerStream[wrapperspb.Int32Value, DM]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetConversationDMsServer = grpc.ServerStreamingServer[DM]

func _Lenic_CreateNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Notification)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).CreateNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_CreateNotification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).CreateNotification(ctx, req.(*Notification))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_GetUserNotifications_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(wrapperspb.StringValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LenicServer).GetUserNotifications(m, &grpc.GenericServerStream[wrapperspb.StringValue, Notification]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserNotificationsServer = grpc.ServerStreamingServer[Notification]

func _Lenic_ReadNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.Int32Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).ReadNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_ReadNotification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).ReadNotification(ctx, req.(*wrapperspb.Int32Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_CreatePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Post)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).CreatePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_CreatePost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).CreatePost(ctx, req.(*Post))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_GetPost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).GetPost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_GetPost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).GetPost(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_GetPostPic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).GetPostPic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_GetPostPic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).GetPostPic(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_GetUserPosts_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(wrapperspb.StringValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LenicServer).GetUserPosts(m, &grpc.GenericServerStream[wrapperspb.StringValue, Post]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserPostsServer = grpc.ServerStreamingServer[Post]

func _Lenic_GetUserPublicPosts_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(wrapperspb.StringValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LenicServer).GetUserPublicPosts(m, &grpc.GenericServerStream[wrapperspb.StringValue, Post]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetUserPublicPostsServer = grpc.ServerStreamingServer[Post]

func _Lenic_RatePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PostRating)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).RatePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_RatePost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).RatePost(ctx, req.(*PostRating))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_UpdatePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Post)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).UpdatePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_UpdatePost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).UpdatePost(ctx, req.(*Post))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_DeletePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).DeletePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_DeletePost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).DeletePost(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_CreateComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).CreateComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_CreateComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).CreateComment(ctx, req.(*Comment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_GetComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.Int32Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).GetComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_GetComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).GetComment(ctx, req.(*wrapperspb.Int32Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_GetCommentsFromPost_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(wrapperspb.StringValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LenicServer).GetCommentsFromPost(m, &grpc.GenericServerStream[wrapperspb.StringValue, Comment]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lenic_GetCommentsFromPostServer = grpc.ServerStreamingServer[Comment]

func _Lenic_RateComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommentRating)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).RateComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_RateComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).RateComment(ctx, req.(*CommentRating))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_UpdateComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).UpdateComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_UpdateComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).UpdateComment(ctx, req.(*Comment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lenic_DeleteComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LenicServer).DeleteComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lenic_DeleteComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LenicServer).DeleteComment(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

// Lenic_ServiceDesc is the grpc.ServiceDesc for Lenic service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Lenic_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lenic.Lenic",
	HandlerType: (*LenicServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _Lenic_CreateUser_Handler,
		},
		{
			MethodName: "ActivateUser",
			Handler:    _Lenic_ActivateUser_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _Lenic_GetUser_Handler,
		},
		{
			MethodName: "TagUser",
			Handler:    _Lenic_TagUser_Handler,
		},
		{
			MethodName: "FollowUser",
			Handler:    _Lenic_FollowUser_Handler,
		},
		{
			MethodName: "AcceptFollow",
			Handler:    _Lenic_AcceptFollow_Handler,
		},
		{
			MethodName: "UnfollowUser",
			Handler:    _Lenic_UnfollowUser_Handler,
		},
		{
			MethodName: "UpdateUserPass",
			Handler:    _Lenic_UpdateUserPass_Handler,
		},
		{
			MethodName: "UpdateUserProfilePic",
			Handler:    _Lenic_UpdateUserProfilePic_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _Lenic_DeleteUser_Handler,
		},
		{
			MethodName: "StartConversation",
			Handler:    _Lenic_StartConversation_Handler,
		},
		{
			MethodName: "ReadConversation",
			Handler:    _Lenic_ReadConversation_Handler,
		},
		{
			MethodName: "SendDM",
			Handler:    _Lenic_SendDM_Handler,
		},
		{
			MethodName: "CreateNotification",
			Handler:    _Lenic_CreateNotification_Handler,
		},
		{
			MethodName: "ReadNotification",
			Handler:    _Lenic_ReadNotification_Handler,
		},
		{
			MethodName: "CreatePost",
			Handler:    _Lenic_CreatePost_Handler,
		},
		{
			MethodName: "GetPost",
			Handler:    _Lenic_GetPost_Handler,
		},
		{
			MethodName: "GetPostPic",
			Handler:    _Lenic_GetPostPic_Handler,
		},
		{
			MethodName: "RatePost",
			Handler:    _Lenic_RatePost_Handler,
		},
		{
			MethodName: "UpdatePost",
			Handler:    _Lenic_UpdatePost_Handler,
		},
		{
			MethodName: "DeletePost",
			Handler:    _Lenic_DeletePost_Handler,
		},
		{
			MethodName: "CreateComment",
			Handler:    _Lenic_CreateComment_Handler,
		},
		{
			MethodName: "GetComment",
			Handler:    _Lenic_GetComment_Handler,
		},
		{
			MethodName: "RateComment",
			Handler:    _Lenic_RateComment_Handler,
		},
		{
			MethodName: "UpdateComment",
			Handler:    _Lenic_UpdateComment_Handler,
		},
		{
			MethodName: "DeleteComment",
			Handler:    _Lenic_DeleteComment_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SearchUsers",
			Handler:       _Lenic_SearchUsers_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetUserFollowers",
			Handler:       _Lenic_GetUserFollowers_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetUserFollowing",
			Handler:       _Lenic_GetUserFollowing_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetUserConversations",
			Handler:       _Lenic_GetUserConversations_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetConversationDMs",
			Handler:       _Lenic_GetConversationDMs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetUserNotifications",
			Handler:       _Lenic_GetUserNotifications_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetUserPosts",
			Handler:       _Lenic_GetUserPosts_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetUserPublicPosts",
			Handler:       _Lenic_GetUserPublicPosts_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetCommentsFromPost",
			Handler:       _Lenic_GetCommentsFromPost_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "lenic.proto",
}
